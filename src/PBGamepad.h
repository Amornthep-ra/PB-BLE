// PBGamepad.h
#ifndef PB_GAMEPAD_H
#define PB_GAMEPAD_H

#include <Arduino.h>

static const uint16_t PB_BLE_BTN_UP = 1 << 0;
static const uint16_t PB_BLE_BTN_DOWN = 1 << 1;
static const uint16_t PB_BLE_BTN_LEFT = 1 << 2;
static const uint16_t PB_BLE_BTN_RIGHT = 1 << 3;
static const uint16_t PB_BLE_BTN_TRIANGLE = 1 << 4;
static const uint16_t PB_BLE_BTN_CROSS = 1 << 5;
static const uint16_t PB_BLE_BTN_SQUARE = 1 << 6;
static const uint16_t PB_BLE_BTN_CIRCLE = 1 << 7;
static const uint16_t PB_BLE_BTN_SPEED_LOW = 1 << 8;
static const uint16_t PB_BLE_BTN_SPEED_MID = 1 << 9;
static const uint16_t PB_BLE_BTN_SPEED_HIGH = 1 << 10;

void PBGamepad_init(const char *deviceName);
String PBGamepad_getCommand(void);

void PBGamepad_sendLine(const String &msg);
bool PBGamepad_isConnected(void);

bool PBGamepad_hasBinary(void);
float PBGamepad_getLX(void);
float PBGamepad_getLY(void);
float PBGamepad_getRX(void);
float PBGamepad_getRY(void);
uint16_t PBGamepad_getButtons(void);
int PBGamepad_getSpeed(void);

// Helpers for cleaner Arduino code (no behavior change).
static inline uint8_t PB_GetButtonsLow(void) {
  uint16_t v = PBGamepad_getButtons();
  return (uint8_t)(v & 0xFF);
}

static inline uint8_t PB_GetSpeedLevel(void) {
  uint16_t v = PBGamepad_getButtons();
  return (uint8_t)((v >> 8) & 0xFF);
}

static inline int PB_SpeedFromLevel(uint8_t level) {
  if (level & 0x01) return 25;
  if (level & 0x02) return 50;
  if (level & 0x04) return 100;
  return 0;
}

static inline int PB_Clamp100(int value) {
  if (value < 0) return 0;
  if (value > 100) return 100;
  return value;
}

static inline bool PB_IsCombo(uint8_t low, uint8_t a, uint8_t b) {
  return ((low & a) != 0) && ((low & b) != 0);
}

static inline int PB_GetDriveSpeed(void) {
  float v = PBGamepad_getLX();
  if (v < 0) v = 0;
  int out = (int)(v * 100.0f + 0.5f);
  return PB_Clamp100(out);
}

static inline int PB_GetTurnSpeed(void) {
  float v = PBGamepad_getRX();
  if (v < 0) v = 0;
  int out = (int)(v * 100.0f + 0.5f);
  return PB_Clamp100(out);
}

// Read 0xAA 0x55 + 4-byte payload from Serial1.
// Returns true when a full packet was decoded.
static inline bool PB_ReadPuppybotPacket(uint8_t &low, uint8_t &level, uint8_t &drv, uint8_t &trn) {
  static uint8_t state = 0;
  static uint8_t buf[4];
  static uint8_t idx = 0;

  while (Serial1.available() > 0) {
    int byteIn = Serial1.read();
    if (state == 0) {
      if (byteIn == 170) {
        state = 1;
      }
    } else if (state == 1) {
      if (byteIn == 85) {
        state = 2;
        idx = 0;
      } else if (byteIn == 170) {
        state = 1;
      } else {
        state = 0;
      }
    } else if (state == 2) {
      buf[idx++] = (uint8_t)byteIn;
      if (idx >= 4) {
        uint8_t newLow = buf[0];
        uint8_t newLevel = buf[1];
        uint8_t newDrv = buf[2];
        uint8_t newTrn = buf[3];
        bool ok = (newLevel == 0 || newLevel == 1 || newLevel == 2 || newLevel == 4);
        ok = ok && (newDrv <= 100) && (newTrn <= 100);
        if (ok) {
          low = newLow;
          level = newLevel;
          drv = newDrv;
          trn = newTrn;
          state = 0;
          return true;
        }
        state = 0;
      }
    }
  }
  return false;
}

// Overload for Number/float variables generated by blocks.
static inline bool PB_ReadPuppybotPacket(float &low, float &level, float &drv, float &trn) {
  uint8_t l = 0;
  uint8_t lv = 0;
  uint8_t d = 0;
  uint8_t t = 0;
  if (!PB_ReadPuppybotPacket(l, lv, d, t)) {
    return false;
  }
  low = (float)l;
  level = (float)lv;
  drv = (float)d;
  trn = (float)t;
  return true;
}

#endif


